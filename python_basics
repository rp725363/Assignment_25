1) . What is the difference between enclosing a list comprehension in square brackets and parentheses?
Ans:-
Square Brackets [] - List Comprehension: When you enclose a list comprehension in square brackets, it produces a list object. The resulting object is a new list that contains the evaluated elements generated by the list comprehension.
Parentheses () - Generator Expression: When you enclose a comprehension in parentheses, it produces a generator expression. The resulting object is a generator, which is an iterator that generates values on the fly, as they are needed. Generator expressions are more memory-efficient compared to lists because they don't store all the values in memory at once.
2) What is the relationship between generators and iterators?
Ans:-
Iterators: In Python, an iterator is an object that implements the iterator protocol, which consists of two methods: __iter__() and __next__(). Iterators allow you to traverse over a sequence of elements, providing access to one element at a time. The __iter__() method returns the iterator object itself, and the __next__() method returns the next element in the sequence or raises the StopIteration exception if there are no more elements.
Generators: Generators are a type of iterator that can be defined using generator functions or generator expressions. Generator functions are defined like regular functions but use the yield keyword instead of return. When a generator function is called, it returns a generator object, which is an iterator. Generator expressions, on the other hand, are similar to list comprehensions but are enclosed in parentheses () instead of square brackets []. Generator functions and expressions allow you to define iterators in a more concise and memory-efficient way
3) What are the signs that a function is a generator function?
Ans:-
Use of the yield keyword: Generator functions use the yield keyword instead of the return keyword to produce a series of values. The yield statement suspends the function's execution and returns a value to the caller, but it also saves the function's state, allowing it to resume where it left off when called again.
Presence of the yield statement: A generator function must have at least one yield statement within its body. The yield statement specifies the value to be yielded and temporarily suspends the function's execution until the next iteration.
Function returns a generator object: When a generator function is called, it returns a generator object rather than a specific value. The generator object is an iterator that can be used to iterate over the values produced by the generator function.
Iteration behavior: Generator functions are typically used in iterations, such as with for loops or by calling the next() function on the generator object. Each iteration of a generator function resumes execution from where it left off, yielding the next value in the sequence.

4) What is the purpose of a yield statement?
Ans:-
The current state of the function's execution is saved, including all variable values and the point at which the yield statement was encountered.
The yielded value is returned to the caller of the function.
The function is suspended, and the next time the function is called, it resumes execution from where it left off, picking up the saved state.
5) What is the relationship between map calls and list comprehensions? Make a comparison and contrast between the two.
Ans:-
Map Calls:
Syntax: The map() function takes two arguments: a function and an iterable (e.g., list, tuple). The function is applied to each element of the iterable, and a new iterable containing the results is returned.
Purpose: The primary purpose of map() is to apply a given function to each element of an iterable and collect the results.
Return Value: map() returns a map object, which is an iterable. To obtain the result values, you can convert the map object to a list or iterate over it using a loop or other iterable-consuming functions.

List Comprehensions:
Syntax: List comprehensions have a concise syntax that allows you to create new lists by specifying the transformation or filtering logic within square brackets. They consist of an expression followed by a for clause and optional if clauses.
Purpose: List comprehensions provide a compact and readable way to create new lists by transforming or filtering existing sequences.
Return Value: List comprehensions directly return a new list containing the evaluated elements, without the need for an additional conversion.
